"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var react_1 = require("react");
var react_leaflet_1 = require("react-leaflet");
var models_1 = require("./models");
var utilities_1 = require("./utilities");
exports.CircleLayer = function (_a) {
    var layer = _a.layer;
    return (React.createElement(react_leaflet_1.Circle, { key: layer.id, color: layer.color || 'white', 
        // @ts-ignore convertWebViewLeafletLatLngToNumberArray can handle single, array, or 2dArray
        center: utilities_1.convertWebViewLeafletLatLngToNumberArray(layer.center), radius: layer.radius, attribution: layer.attribution || null }));
};
var VectorLayers = function (_a) {
    var addDebugMessage = _a.addDebugMessage, debugMessages = _a.debugMessages, vectorLayers = _a.vectorLayers;
    var _b = react_1.useState([]), layerIds = _b[0], setLayerIds = _b[1];
    // Use this to only add to the parent's debug message array when
    // this functions debug message array changes
    react_1.useEffect(function () {
        addDebugMessage(layerIds);
    }, [layerIds]);
    return (React.createElement(React.Fragment, null, vectorLayers.map(function (mapVectorLayer, index) {
        var layerId = mapVectorLayer.id || index;
        if (!layerIds.includes(JSON.stringify(mapVectorLayer))) {
            setLayerIds(__spreadArrays(layerIds, [JSON.stringify(mapVectorLayer)]));
        }
        switch (mapVectorLayer.type) {
            case models_1.MapVectorLayerType.CIRCLE:
                return (React.createElement(exports.CircleLayer, { layer: mapVectorLayer }));
            case models_1.MapVectorLayerType.CIRCLE_MARKER: {
                var layer = mapVectorLayer;
                return (React.createElement(react_leaflet_1.CircleMarker, { key: mapVectorLayer.id, color: layer.color || 'white', 
                    // @ts-ignore convertWebViewLeafletLatLngToNumberArray can handle single, array, or 2dArray
                    center: convertSingleLatLngToNumberArray(layer.center), radius: layer.radius, attribution: layer.attribution || null }));
            }
            case models_1.MapVectorLayerType.POLYGON: {
                var layer = mapVectorLayer;
                return (React.createElement(react_leaflet_1.Polygon, { key: mapVectorLayer.id, color: layer.color || 'white', 
                    // @ts-ignore convertWebViewLeafletLatLngToNumberArray can handle single, array, or 2dArray
                    positions: utilities_1.convertWebViewLeafletLatLngToNumberArray(layer.positions), attribution: layer.attribution || null }));
            }
            case models_1.MapVectorLayerType.POLYLINE: {
                var layer = mapVectorLayer;
                return (React.createElement(react_leaflet_1.Polyline, { key: mapVectorLayer.id, color: layer.color || 'white', 
                    // @ts-ignore convertWebViewLeafletLatLngToNumberArray can handle single, array, or 2dArray
                    positions: utilities_1.convertWebViewLeafletLatLngToNumberArray(layer.positions), attribution: layer.attribution || null }));
            }
            case models_1.MapVectorLayerType.RECTANGLE: {
                var layer = mapVectorLayer;
                return (React.createElement(react_leaflet_1.Rectangle, { key: mapVectorLayer.id, color: layer.color || 'white', 
                    // @ts-ignore convertWebViewLeafletLatLngToNumberArray can handle single, array, or 2dArray
                    bounds: utilities_1.convertWebViewLeafletLatLngToNumberArray(layer.bounds), attribution: layer.attribution || null }));
            }
            default:
                console.warn('Unknown vector layer type', mapVectorLayer.type);
        }
    })));
};
exports.default = VectorLayers;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVmVjdG9yTGF5ZXJzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vcHJlY29tcGlsZS9WZWN0b3JMYXllcnMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLDZCQUErQjtBQUMvQiwrQkFBNEM7QUFDNUMsK0NBT3VCO0FBQ3ZCLG1DQU9rQjtBQUNsQix5Q0FBdUU7QUFjMUQsUUFBQSxXQUFXLEdBQUcsVUFBQyxFQUEwQztRQUF4QyxnQkFBSztJQUNqQyxPQUFPLENBQ0wsb0JBQUMsc0JBQU0sSUFDTCxHQUFHLEVBQUUsS0FBSyxDQUFDLEVBQUUsRUFDYixLQUFLLEVBQUUsS0FBSyxDQUFDLEtBQUssSUFBSSxPQUFPO1FBQzdCLDJGQUEyRjtRQUMzRixNQUFNLEVBQUUsb0RBQXdDLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxFQUM5RCxNQUFNLEVBQUUsS0FBSyxDQUFDLE1BQU0sRUFDcEIsV0FBVyxFQUFFLEtBQUssQ0FBQyxXQUFXLElBQUksSUFBSSxHQUN0QyxDQUNILENBQUM7QUFDSixDQUFDLENBQUM7QUFFRixJQUFNLFlBQVksR0FBRyxVQUFDLEVBSWQ7UUFITixvQ0FBZSxFQUNmLGdDQUFhLEVBQ2IsOEJBQVk7SUFFTixJQUFBLHlCQUE2QyxFQUE1QyxnQkFBUSxFQUFFLG1CQUFrQyxDQUFDO0lBRXBELGdFQUFnRTtJQUNoRSw2Q0FBNkM7SUFDN0MsaUJBQVMsQ0FBQztRQUNSLGVBQWUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUM1QixDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0lBRWYsT0FBTyxDQUNMLDBDQUNHLFlBQVksQ0FBQyxHQUFHLENBQUMsVUFBQyxjQUFjLEVBQUUsS0FBSztRQUN0QyxJQUFNLE9BQU8sR0FBRyxjQUFjLENBQUMsRUFBRSxJQUFJLEtBQUssQ0FBQztRQUMzQyxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLGNBQWMsQ0FBQyxDQUFDLEVBQUU7WUFDdEQsV0FBVyxnQkFBSyxRQUFRLEdBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUMsR0FBRSxDQUFDO1NBQzVEO1FBRUQsUUFBUSxjQUFjLENBQUMsSUFBSSxFQUFFO1lBQzNCLEtBQUssMkJBQWtCLENBQUMsTUFBTTtnQkFDNUIsT0FBTyxDQUNMLG9CQUFDLG1CQUFXLElBQUMsS0FBSyxFQUFFLGNBQXNDLEdBQUksQ0FDL0QsQ0FBQztZQUVKLEtBQUssMkJBQWtCLENBQUMsYUFBYSxDQUFDLENBQUM7Z0JBQ3JDLElBQUksS0FBSyxHQUFHLGNBQTRDLENBQUM7Z0JBQ3pELE9BQU8sQ0FDTCxvQkFBQyw0QkFBWSxJQUNYLEdBQUcsRUFBRSxjQUFjLENBQUMsRUFBRSxFQUN0QixLQUFLLEVBQUUsS0FBSyxDQUFDLEtBQUssSUFBSSxPQUFPO29CQUM3QiwyRkFBMkY7b0JBQzNGLE1BQU0sRUFBRSxnQ0FBZ0MsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEVBQ3RELE1BQU0sRUFBRSxLQUFLLENBQUMsTUFBTSxFQUNwQixXQUFXLEVBQUUsS0FBSyxDQUFDLFdBQVcsSUFBSSxJQUFJLEdBQ3RDLENBQ0gsQ0FBQzthQUNIO1lBQ0QsS0FBSywyQkFBa0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztnQkFDL0IsSUFBSSxLQUFLLEdBQUcsY0FBdUMsQ0FBQztnQkFDcEQsT0FBTyxDQUNMLG9CQUFDLHVCQUFPLElBQ04sR0FBRyxFQUFFLGNBQWMsQ0FBQyxFQUFFLEVBQ3RCLEtBQUssRUFBRSxLQUFLLENBQUMsS0FBSyxJQUFJLE9BQU87b0JBQzdCLDJGQUEyRjtvQkFDM0YsU0FBUyxFQUFFLG9EQUF3QyxDQUNqRCxLQUFLLENBQUMsU0FBUyxDQUNoQixFQUNELFdBQVcsRUFBRSxLQUFLLENBQUMsV0FBVyxJQUFJLElBQUksR0FDdEMsQ0FDSCxDQUFDO2FBQ0g7WUFDRCxLQUFLLDJCQUFrQixDQUFDLFFBQVEsQ0FBQyxDQUFDO2dCQUNoQyxJQUFJLEtBQUssR0FBRyxjQUF3QyxDQUFDO2dCQUNyRCxPQUFPLENBQ0wsb0JBQUMsd0JBQVEsSUFDUCxHQUFHLEVBQUUsY0FBYyxDQUFDLEVBQUUsRUFDdEIsS0FBSyxFQUFFLEtBQUssQ0FBQyxLQUFLLElBQUksT0FBTztvQkFDN0IsMkZBQTJGO29CQUMzRixTQUFTLEVBQUUsb0RBQXdDLENBQ2pELEtBQUssQ0FBQyxTQUFTLENBQ2hCLEVBQ0QsV0FBVyxFQUFFLEtBQUssQ0FBQyxXQUFXLElBQUksSUFBSSxHQUN0QyxDQUNILENBQUM7YUFDSDtZQUNELEtBQUssMkJBQWtCLENBQUMsU0FBUyxDQUFDLENBQUM7Z0JBQ2pDLElBQUksS0FBSyxHQUFHLGNBQXlDLENBQUM7Z0JBQ3RELE9BQU8sQ0FDTCxvQkFBQyx5QkFBUyxJQUNSLEdBQUcsRUFBRSxjQUFjLENBQUMsRUFBRSxFQUN0QixLQUFLLEVBQUUsS0FBSyxDQUFDLEtBQUssSUFBSSxPQUFPO29CQUM3QiwyRkFBMkY7b0JBQzNGLE1BQU0sRUFBRSxvREFBd0MsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEVBQzlELFdBQVcsRUFBRSxLQUFLLENBQUMsV0FBVyxJQUFJLElBQUksR0FDdEMsQ0FDSCxDQUFDO2FBQ0g7WUFDRDtnQkFDRSxPQUFPLENBQUMsSUFBSSxDQUFDLDJCQUEyQixFQUFFLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNsRTtJQUNILENBQUMsQ0FBQyxDQUNELENBQ0osQ0FBQztBQUNKLENBQUMsQ0FBQztBQUVGLGtCQUFlLFlBQVksQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHtcclxuICBDaXJjbGUsXHJcbiAgTGF5ZXJHcm91cCxcclxuICBQb2x5Z29uLFxyXG4gIENpcmNsZU1hcmtlcixcclxuICBQb2x5bGluZSxcclxuICBSZWN0YW5nbGVcclxufSBmcm9tICdyZWFjdC1sZWFmbGV0JztcclxuaW1wb3J0IHtcclxuICBNYXBWZWN0b3JMYXllclR5cGUsXHJcbiAgTWFwVmVjdG9yTGF5ZXJDaXJjbGUsXHJcbiAgTWFwVmVjdG9yTGF5ZXJDaXJjbGVNYXJrZXIsXHJcbiAgTWFwVmVjdG9yTGF5ZXJQb2x5bGluZSxcclxuICBNYXBWZWN0b3JMYXllclBvbHlnb24sXHJcbiAgTWFwVmVjdG9yTGF5ZXJSZWN0YW5nbGVcclxufSBmcm9tICcuL21vZGVscyc7XHJcbmltcG9ydCB7IGNvbnZlcnRXZWJWaWV3TGVhZmxldExhdExuZ1RvTnVtYmVyQXJyYXkgfSBmcm9tICcuL3V0aWxpdGllcyc7XHJcblxyXG5pbnRlcmZhY2UgUHJvcHMge1xyXG4gIGFkZERlYnVnTWVzc2FnZTogKG1zZzogYW55KSA9PiB2b2lkO1xyXG4gIGRlYnVnTWVzc2FnZXM6IHN0cmluZ1tdO1xyXG4gIHZlY3RvckxheWVyczogKFxyXG4gICAgfCBNYXBWZWN0b3JMYXllckNpcmNsZVxyXG4gICAgfCBNYXBWZWN0b3JMYXllckNpcmNsZU1hcmtlclxyXG4gICAgfCBNYXBWZWN0b3JMYXllclBvbHlsaW5lXHJcbiAgICB8IE1hcFZlY3RvckxheWVyUG9seWdvblxyXG4gICAgfCBNYXBWZWN0b3JMYXllclJlY3RhbmdsZVxyXG4gIClbXTtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IENpcmNsZUxheWVyID0gKHsgbGF5ZXIgfTogeyBsYXllcjogTWFwVmVjdG9yTGF5ZXJDaXJjbGUgfSkgPT4ge1xyXG4gIHJldHVybiAoXHJcbiAgICA8Q2lyY2xlXHJcbiAgICAgIGtleT17bGF5ZXIuaWR9XHJcbiAgICAgIGNvbG9yPXtsYXllci5jb2xvciB8fCAnd2hpdGUnfVxyXG4gICAgICAvLyBAdHMtaWdub3JlIGNvbnZlcnRXZWJWaWV3TGVhZmxldExhdExuZ1RvTnVtYmVyQXJyYXkgY2FuIGhhbmRsZSBzaW5nbGUsIGFycmF5LCBvciAyZEFycmF5XHJcbiAgICAgIGNlbnRlcj17Y29udmVydFdlYlZpZXdMZWFmbGV0TGF0TG5nVG9OdW1iZXJBcnJheShsYXllci5jZW50ZXIpfVxyXG4gICAgICByYWRpdXM9e2xheWVyLnJhZGl1c31cclxuICAgICAgYXR0cmlidXRpb249e2xheWVyLmF0dHJpYnV0aW9uIHx8IG51bGx9XHJcbiAgICAvPlxyXG4gICk7XHJcbn07XHJcblxyXG5jb25zdCBWZWN0b3JMYXllcnMgPSAoe1xyXG4gIGFkZERlYnVnTWVzc2FnZSxcclxuICBkZWJ1Z01lc3NhZ2VzLFxyXG4gIHZlY3RvckxheWVyc1xyXG59OiBQcm9wcykgPT4ge1xyXG4gIGNvbnN0IFtsYXllcklkcywgc2V0TGF5ZXJJZHNdID0gdXNlU3RhdGU8YW55W10+KFtdKTtcclxuXHJcbiAgLy8gVXNlIHRoaXMgdG8gb25seSBhZGQgdG8gdGhlIHBhcmVudCdzIGRlYnVnIG1lc3NhZ2UgYXJyYXkgd2hlblxyXG4gIC8vIHRoaXMgZnVuY3Rpb25zIGRlYnVnIG1lc3NhZ2UgYXJyYXkgY2hhbmdlc1xyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBhZGREZWJ1Z01lc3NhZ2UobGF5ZXJJZHMpO1xyXG4gIH0sIFtsYXllcklkc10pO1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPD5cclxuICAgICAge3ZlY3RvckxheWVycy5tYXAoKG1hcFZlY3RvckxheWVyLCBpbmRleCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGxheWVySWQgPSBtYXBWZWN0b3JMYXllci5pZCB8fCBpbmRleDtcclxuICAgICAgICBpZiAoIWxheWVySWRzLmluY2x1ZGVzKEpTT04uc3RyaW5naWZ5KG1hcFZlY3RvckxheWVyKSkpIHtcclxuICAgICAgICAgIHNldExheWVySWRzKFsuLi5sYXllcklkcywgSlNPTi5zdHJpbmdpZnkobWFwVmVjdG9yTGF5ZXIpXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzd2l0Y2ggKG1hcFZlY3RvckxheWVyLnR5cGUpIHtcclxuICAgICAgICAgIGNhc2UgTWFwVmVjdG9yTGF5ZXJUeXBlLkNJUkNMRTpcclxuICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICA8Q2lyY2xlTGF5ZXIgbGF5ZXI9e21hcFZlY3RvckxheWVyIGFzIE1hcFZlY3RvckxheWVyQ2lyY2xlfSAvPlxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIGNhc2UgTWFwVmVjdG9yTGF5ZXJUeXBlLkNJUkNMRV9NQVJLRVI6IHtcclxuICAgICAgICAgICAgbGV0IGxheWVyID0gbWFwVmVjdG9yTGF5ZXIgYXMgTWFwVmVjdG9yTGF5ZXJDaXJjbGVNYXJrZXI7XHJcbiAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgPENpcmNsZU1hcmtlclxyXG4gICAgICAgICAgICAgICAga2V5PXttYXBWZWN0b3JMYXllci5pZH1cclxuICAgICAgICAgICAgICAgIGNvbG9yPXtsYXllci5jb2xvciB8fCAnd2hpdGUnfVxyXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBjb252ZXJ0V2ViVmlld0xlYWZsZXRMYXRMbmdUb051bWJlckFycmF5IGNhbiBoYW5kbGUgc2luZ2xlLCBhcnJheSwgb3IgMmRBcnJheVxyXG4gICAgICAgICAgICAgICAgY2VudGVyPXtjb252ZXJ0U2luZ2xlTGF0TG5nVG9OdW1iZXJBcnJheShsYXllci5jZW50ZXIpfVxyXG4gICAgICAgICAgICAgICAgcmFkaXVzPXtsYXllci5yYWRpdXN9XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGlvbj17bGF5ZXIuYXR0cmlidXRpb24gfHwgbnVsbH1cclxuICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY2FzZSBNYXBWZWN0b3JMYXllclR5cGUuUE9MWUdPTjoge1xyXG4gICAgICAgICAgICBsZXQgbGF5ZXIgPSBtYXBWZWN0b3JMYXllciBhcyBNYXBWZWN0b3JMYXllclBvbHlnb247XHJcbiAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgPFBvbHlnb25cclxuICAgICAgICAgICAgICAgIGtleT17bWFwVmVjdG9yTGF5ZXIuaWR9XHJcbiAgICAgICAgICAgICAgICBjb2xvcj17bGF5ZXIuY29sb3IgfHwgJ3doaXRlJ31cclxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgY29udmVydFdlYlZpZXdMZWFmbGV0TGF0TG5nVG9OdW1iZXJBcnJheSBjYW4gaGFuZGxlIHNpbmdsZSwgYXJyYXksIG9yIDJkQXJyYXlcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9ucz17Y29udmVydFdlYlZpZXdMZWFmbGV0TGF0TG5nVG9OdW1iZXJBcnJheShcclxuICAgICAgICAgICAgICAgICAgbGF5ZXIucG9zaXRpb25zXHJcbiAgICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRpb249e2xheWVyLmF0dHJpYnV0aW9uIHx8IG51bGx9XHJcbiAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGNhc2UgTWFwVmVjdG9yTGF5ZXJUeXBlLlBPTFlMSU5FOiB7XHJcbiAgICAgICAgICAgIGxldCBsYXllciA9IG1hcFZlY3RvckxheWVyIGFzIE1hcFZlY3RvckxheWVyUG9seWxpbmU7XHJcbiAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgPFBvbHlsaW5lXHJcbiAgICAgICAgICAgICAgICBrZXk9e21hcFZlY3RvckxheWVyLmlkfVxyXG4gICAgICAgICAgICAgICAgY29sb3I9e2xheWVyLmNvbG9yIHx8ICd3aGl0ZSd9XHJcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIGNvbnZlcnRXZWJWaWV3TGVhZmxldExhdExuZ1RvTnVtYmVyQXJyYXkgY2FuIGhhbmRsZSBzaW5nbGUsIGFycmF5LCBvciAyZEFycmF5XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbnM9e2NvbnZlcnRXZWJWaWV3TGVhZmxldExhdExuZ1RvTnVtYmVyQXJyYXkoXHJcbiAgICAgICAgICAgICAgICAgIGxheWVyLnBvc2l0aW9uc1xyXG4gICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0aW9uPXtsYXllci5hdHRyaWJ1dGlvbiB8fCBudWxsfVxyXG4gICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjYXNlIE1hcFZlY3RvckxheWVyVHlwZS5SRUNUQU5HTEU6IHtcclxuICAgICAgICAgICAgbGV0IGxheWVyID0gbWFwVmVjdG9yTGF5ZXIgYXMgTWFwVmVjdG9yTGF5ZXJSZWN0YW5nbGU7XHJcbiAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgPFJlY3RhbmdsZVxyXG4gICAgICAgICAgICAgICAga2V5PXttYXBWZWN0b3JMYXllci5pZH1cclxuICAgICAgICAgICAgICAgIGNvbG9yPXtsYXllci5jb2xvciB8fCAnd2hpdGUnfVxyXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBjb252ZXJ0V2ViVmlld0xlYWZsZXRMYXRMbmdUb051bWJlckFycmF5IGNhbiBoYW5kbGUgc2luZ2xlLCBhcnJheSwgb3IgMmRBcnJheVxyXG4gICAgICAgICAgICAgICAgYm91bmRzPXtjb252ZXJ0V2ViVmlld0xlYWZsZXRMYXRMbmdUb051bWJlckFycmF5KGxheWVyLmJvdW5kcyl9XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGlvbj17bGF5ZXIuYXR0cmlidXRpb24gfHwgbnVsbH1cclxuICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdVbmtub3duIHZlY3RvciBsYXllciB0eXBlJywgbWFwVmVjdG9yTGF5ZXIudHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KX1cclxuICAgIDwvPlxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBWZWN0b3JMYXllcnM7XHJcbiJdfQ==